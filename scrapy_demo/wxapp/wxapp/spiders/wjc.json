{"title": "微信小程序开发最佳实践 ", "author": "Rolan", "pub_time": "2018-1-25 00:34", "article_content": "weapp-starter微信小程序开发最佳实践项目地址为什么会有这个 repo在小程序之初便开发应用了，现在小程序的开发也越来越成熟了，完善了很多的API、组件、架构等，社区也由原来的零星点点到现在的不大不小，但也算是有了，期间也诞生了很多的开发框架，越来越多的三方辅助库，我也捣鼓出很多。比较有名的算是 wepy 和 labrador ， wepy是 vue 风格的小程序开发框架， labrador 则比较亲和 React ，各有千秋，也各有深坑，而labrador 作者目前已经停止更新了 TnT，作为React深度使用者的我来说是忧伤的，于是我捣鼓出 wn-cli 来用类 React 快速开发微信小程序，然而在这个过程中，想了很多，为什么需要开发框架呢？小程序本身在一开始就强调框架，且现在做的也不差，后来总结了下，无非是不熟悉小程序这套框架，但学习新的中间框架去开发小程序，这不是更加加大了熟悉成本吗？且出了问题增加了处理的代价。于是，我重新思考了下，最佳的微信小程序开发实践应该是无痛的，且舒服的，无痛的是指在小程序的飞速发展变更中，我们不用重复的浪费学习第三方框架和原生框架。舒服的是指，我们能用上我们熟悉的流行工程流，如：less 预编译、async/await 异步请求，redux数据管理等。以上，便是这个 repo 的意义与原因。设计概要[x] 优化小程序 APIPromise 化异步接口突破请求数量限制（队列）[x] 使用 async/await[x] 接入 Redux 管理页面数据流直接接入，添加可配置项添加 saga 管理操作[x] 样式书写采用 less 预编译使用 Gulp 管理自动编译，持续集成[x] wxs 管理工具库数据的格式化操作，如时间格式化、金币格式化等[x] 按需加载，子页面分包（除却 tab 页面的其他页面）按功能模块分包加载（推荐）按 tab 分包ps: 小程序 原生分包[x] 资源自动化管理上传 CDNPromise 化异步接口由于微信的API中异步接口都是有三个回调函数的，分别是 success ， fail ， complete，执行时机同字面上意思（ complete 一定会在接口的最后执行）。于是 结合 Promise ，简单的描述如下：（以下为简版，具体的可以看源码）原生微信小程序API：wx.request({\r\n  // ... 其他一些配置项\r\n  success: () => {},\r\n  fail: () => {},\r\n  complete: () => {}\r\n});添加 Promise 后：new Promise((resolve, reject) => {\r\n  wx.request({\r\n    // ... 其他一些配置项\r\n    success: resolve,\r\n    fail: reject,\r\n    complete: resolve, // 这里暂取 resolve 来解决\r\n  });\r\n});Promise 化后，使用起来就简单了：wx.request({ /* ...一些配置项 */}).then(res => {\r\n  console.log(res)\r\n}, err => {\r\n  console.error(err)\r\n})结合下面的 async/await 就可以更加方便的书写同步代码使用 async/await添加 babel :yarn add babel-core安装 env presetsyarn add babel-preset-env使用 .babelrc{\r\n  \"presets\": [\r\n    \"env\"\r\n  ]\r\n}在 Gulp 中使用 babel// install\r\nyarn add gulp-babel\r\n\r\nconst babel = require('gulp-babel');\r\n// ...\r\n.pipe(babel())\r\n// ...添加 runtime ，在使用 async/await 的地方引入 ./src/utils/lib/runtime.js 文件，幸运的是这件事情在这个repo中的 Gulp 任务中自动处理了。以上，便可以在微信小程序中使用 async/await 了。样式书写采用 less 预编译为什么选择 less ，因为简单方便，前端编译，轻量级。注意：由于小程序本身的限制，在书写样式的时候，不要使用 less 的嵌套功能！添加less 变量库等// ...\r\n.pipe(addLessImport({\r\n      themePath: path.join(__dirname, './src/theme/index.less'),\r\n      commomPath: path.join(__dirname, './src/app.less'),\r\n    }))\r\n// ...编译// ...\r\n.pipe(less({\r\n      paths: [path.join(__dirname, './src/theme')]\r\n    }))\r\n// ...重命名样式文件，以便小程序识别// ...\r\n  .pipe(rename((path) => {\r\n    path.extname = '.wxss';\r\n  }))\r\n// ...资源自动化管理目前接入阿里云，监测 assert 文件夹，自动上传图片资源根据配置自动生成 less 配置 config.lessgulp.src('src/theme/config.less', { allowEmpty: true })\r\n    .pipe(file('config.less', `@cdn: ~'${config.cdn}';`))\r\n    .pipe(changed('src/theme'))\r\n    .pipe(gulp.dest('src/theme'))使用page {\r\n  background-image: url('@{cdn}/index-bg.png');\r\n  background-attachment: fixed;\r\n}项目地址"}
{"title": "微信小程序使用原生WebSokcet实现断线重连及数据拼接 ", "author": "Rolan", "pub_time": "2018-1-26 00:31", "article_content": "以前做小程序为了应急找了个插件去链接WebSokcet，文章传送门。回过头在新项目中再次使用时出现了些许问题，不一一赘述。遂决定好好用一下原生的WebSokcet。一、说明1.小程序原生的WebSokcet没有断线重连机制，这个是他的不足之处。2.小程序新的版本库已经支持存在多个 WebSokcet 连接。官方说明：基础库 1.7.0 之前，一个微信小程序同时只能有一个 WebSocket 连接，如果当前已存在一个 WebSocket 连接，会自动关闭该连接，并重新创建一个 WebSocket 连接。基础库版本 1.7.0 及以后，支持存在多个 WebSokcet 连接，每次成功调用 wx.connectSocket 会返回一个新的 SocketTask。官方文档地址：https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html#wxclosesocket二、实际例子：首先你需要socket地址url: let url = 'wss://http://xxx.xxx.com/?xxx=xxx'注意：1.小程序管理后台添加socket域名的时候不能出现端口；2.如果使用了appID，协议必须是 wss；3.socket服务端映射的端口仅支持 80 和 443，和公众号一个尿性。接下来放例子：1、socket.jsconst app = getApp();\r\nlet url = 'wss://xxx.xxx.com/?xxx=xxx'\r\nexport const connect = function (cb) { // 定义一个方法\r\n   wx.connectSocket({ // 创建一个 WebSocket 连接\r\n       url: url,\r\n       fail (err) {\r\nif (err) {\r\n               console.log('%cWebSocket连接失败', 'color:red', err)\r\n               app.globalData.socketConnectFail = true // 定义一个全局变量，当链接失败时改变变量的值\r\n}\r\n}\r\n})\r\n\r\n   wx.onSocketOpen(function (res) { // 监听WebSocket连接打开事件。\r\n       console.log('WebSocket打开成功');\r\n       wx.sendSocketMessage({ // 通过 WebSocket 连接发送数据，需要先 wx.connectSocket，并在 wx.onSocketOpen 回调之后才能发送。\r\n           data: String2Base64(), // 用于订阅的参数，视具体情况而定\r\n           success (data) {\r\n               console.log('WebSocket发送消息:', data.errMsg)\r\n},\r\n           fail (err) {\r\n               console.log('Err', err)\r\n}\r\n})\r\n\r\n})\r\n\r\n   wx.onSocketMessage(function (res) { // 监听WebSocket接受到服务器的消息事件。\r\n       console.log('WebSocket接收到消息:', ArryBuffer2Json(res.data));\r\n       cb(ArryBuffer2Json(res.data)); // 将接收到的消息进行回调，如果是ArryBuffer，需要进行转换\r\n})\r\n\r\n   wx.onSocketError(function (res) { // 监听WebSocket错误。\r\n       console.log('WebSocket连接打开失败')\r\n})\r\n\r\n   wx.onSocketClose(function (res) { // 监听WebSocket关闭。\r\n       console.log('WebSocket关闭');\r\n})\r\n};\r\n\r\nfunction ArryBuffer2Json (data) { // ArryBuffer转换成Json\r\ntry {\r\nvar encodedString = String.fromCharCode.apply(null, new Uint8Array(data));\r\nvar decodedString = decodeURIComponent(atob(encodedString));\r\nreturn JSON.parse(decodedString);\r\n} catch (err) {\r\n       console.log(err);\r\nreturn false;\r\n}\r\n}\r\n\r\n\r\nfunction String2Base64 () { // 用于订阅的参数，视具体情况而定\r\nvar packet = {};\r\n   packet[\"cmd\"] = \"subscribe\";\r\n   packet[\"reqNo\"] = \"\" + new Date().getTime();\r\n   packet[\"params\"] = {token: token, channelId: 'xcx', columnIds: \"1\"};\r\nreturn stringToUint(JSON.stringify(packet))\r\n}\r\n\r\nfunction stringToUint (string) {\r\nvar string = base64_encode(encodeURIComponent(string)),\r\n       charList = string.split(''),\r\n       uintArray = [];\r\nfor (var i = 0; i < charList.length; i++) {\r\n       uintArray.push(charList[i].charCodeAt(0));\r\n}\r\nreturn new Uint8Array(uintArray);\r\n}\r\n\r\nfunction base64_encode (str) { // base64转码\r\nvar c1, c2, c3;\r\nvar base64EncodeChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\nvar i = 0, len = str.length, string = '';\r\n\r\nwhile (i < len) {\r\n       c1 = str.charCodeAt(i++) & 0xff;\r\nif (i == len) {\r\nstring += base64EncodeChars.charAt(c1 >> 2);\r\nstring += base64EncodeChars.charAt((c1 & 0x3) << 4);\r\nstring += \"==\";\r\nbreak;\r\n}\r\n       c2 = str.charCodeAt(i++);\r\nif (i == len) {\r\nstring += base64EncodeChars.charAt(c1 >> 2);\r\nstring += base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));\r\nstring += base64EncodeChars.charAt((c2 & 0xF) << 2);\r\nstring += \"=\";\r\nbreak;\r\n}\r\n       c3 = str.charCodeAt(i++);\r\nstring += base64EncodeChars.charAt(c1 >> 2);\r\nstring += base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));\r\nstring += base64EncodeChars.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6));\r\nstring += base64EncodeChars.charAt(c3 & 0x3F)\r\n}\r\nreturn string\r\n}\r\n2、index.jslet openSocket = require('../../config/socket.js');\r\nconst app = getApp();\r\ndata: {\r\n  motto: 'Hello World',\r\n  articleData: []\r\n},\r\nonLoad: function () {\r\nlet that = this;\r\n  openSocket.connect(function (data) { // WebSocket初始化连接\r\nlet result = data.data\r\nif (result) {\r\n          that.setData({articleData: [result].concat(that.data.articleData)}) // 将获得的socket推送消息拼接到当前文章列表的最前面\r\n}\r\n});\r\nif (app.globalData.socketConnectFail) { // WebSocket断线重连\r\n      setInterval(() => {\r\n          openSocket.connect(function (data) {\r\nlet result = data.data\r\nif (result) {\r\n                  that.setData({articleData: [result].concat(that.data.articleData)})\r\n}\r\n});\r\n}, 1000)\r\n}\r\n} \r\n3、app.jsglobalData: {\r\n  socketConnectFail: false\r\n}"}
{"title": "微信小程序没有授权时的处理方法 ", "author": "Rolan", "pub_time": "2018-1-27 00:17", "article_content": "背景：微信小程序很多都需要用户的微信授权，可是很多瓜皮用户会狠心拒绝，但是不管用户怎么操作，我们必须让用户能够更好的体验小程序。过程：我把用户的操作分四种。1）用户直接同意授权。 2）用户拒绝授权，进入引导弹窗，用户继续拒绝授权。 3）用户拒绝授权，进入引导弹窗，用户点击授权，进入授权设置页，用户点击授权。 4）用户拒绝授权，进入引导弹窗，用户点击授权，进入授权设置页，用户不点击授权，直接退出。解决方法：  toMap() {    let that = this;    wx.getSetting({      success(res) {        if (!res.authSetting['scope.userLocation']) {//如果没有授权          wx.authorize({            scope: 'scope.userLocation',            success: res => {//第一种情况：用户同意授权              // 发送地图              that.toMapFin();            }, fail: res => {//用户点击了取消授权，引导其去授权              wx.showModal({                title: '提示',                content: '定位需要您的微信授权才能使用哦~ 错过授权页面的处理方法：删除小程序->重新搜索五百强名片进入->点击授权按钮',                cancelText: \"不授权\",                confirmText: \"授权\",                confirmColor: \"#a08250\",                success: function (res) {                  if (res.confirm) {                    // 这个 API 是基础库 1.1.0 才有的，所以需要做兼容处理：                    if (wx.openSetting) {                      wx.openSetting({                        success: function (res) {//第三种情况：用户拒绝授权，进入引导弹窗，用户点击授权，进入授权设置页，用户点击授权。                           that.toMapFin();                        }                      })                    } else {                      wx.showModal({                        title: '授权提示',                        content: '定位需要您的微信授权才能使用哦~ 错过授权页面的处理方法：删除小程序->重新搜索五百强名片进入->点击授权按钮'                      })                    }                  } else if (res.cancel) {//第二种情况：用户拒绝授权，进入引导弹窗，用户继续拒绝授权。                    wx.showModal({                      title: '提示',                      content: '定位失败，错过授权页面的处理方法：删除小程序->重新搜索五百强名片进入->点击授权按钮',                      showCancel: false,                      confirmColor: \"#c00\",                      success: function (res) {                        if (res.confirm) {                          console.log('用户点击确定')                        }                      }                    })                  }                }              })            }          })        } else {//用户原来已经通过了授权，不必重新调起授权界面。          that.toMapFin();        }      }    })  },  toMapFin(){    wx.chooseLocation({      success: res => {        console.log(res)        let address = res.address + res.name;        this.setData({          \"local.address\": [address],          \"local.longitude\": res.longitude,          \"local.latitude\": res.latitude        })      },      fail: res => { //第四种情况：用户拒绝授权，进入引导弹窗，用户点击授权，进入授权设置页，用户不点击授权，直接退出。        wx.showModal({          title: '提示',          content: '定位失败',          showCancel: false,          confirmColor: \"#c00\",          success: function (res) { }        })      }    })  },这样做的话，每次用户进来都会查看他是否已经授权，如果不授权的话，都会调起授权提示。如果是用户点击拒绝授权之后，以后每次进来都再也不调起授权提示的话，这个方法就不适合了。需要用到的方法：wx:getSetting（获取用户的当前设置。）wx.authorize（提前向用户发起授权请求。调用后会立刻弹窗询问用户是否同意授权小程序使用某项功能或获取用户的某些数据，但不会实际调用对应接口。如果用户之前已经同意授权，则不会出现弹窗，直接返回成功。）wx.openSetting（调起客户端小程序设置界面，返回用户设置的操作结果。）"}
{"title": "微信小程序：防止多次点击跳转（函数节流） ", "author": "Rolan", "pub_time": "2018-1-26 00:24", "article_content": "场景在使用小程序的时候会出现这样一种情况：当网络条件差或卡顿的情况下，使用者会认为点击无效而进行多次点击，最后出现多次跳转页面的情况，就像下图（快速点击了两次）：解决办法然后从 轻松理解JS函数节流和函数防抖 中找到了解决办法，就是函数节流(throttle)：函数在一段时间内多次触发只会执行第一次，在这段时间结束前，不管触发多少次也不会执行函数。/utils/util.js:function throttle(fn, gapTime) {\r\n    if (gapTime == null || gapTime == undefined) {\r\n        gapTime = 1500\r\n    }\r\n\r\n    let _lastTime = null\r\n    return function () {\r\n        let _nowTime = + new Date()\r\n        if (_nowTime - _lastTime > gapTime || !_lastTime) {\r\n            fn()\r\n            _lastTime = _nowTime\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n  throttle: throttle\r\n}/pages/throttle/throttle.wxml:<button bindtap='tap' data-key='abc'>tap</button>/pages/throttle/throttle.jsconst util = require('../../utils/util.js')\r\n\r\nPage({\r\n    data: {\r\n        text: 'tomfriwel'\r\n    },\r\n    onLoad: function (options) {\r\n\r\n    },\r\n    tap: util.throttle(function (e) {\r\n        console.log(this)\r\n        console.log(e)\r\n        console.log((new Date()).getSeconds())\r\n    }, 1000)\r\n})这样，疯狂点击按钮也只会1s触发一次。但是这样的话出现一个问题，就是当你想要获取this.data得到的this是undefined, 或者想要获取微信组件button传递给点击函数的数据e也是undefined，所以throttle函数还需要做一点处理来使其能用在微信小程序的页面js里。出现这种情况的原因是throttle返回的是一个新函数，已经不是最初的函数了。新函数包裹着原函数，所以组件button传递的参数是在新函数里。所以我们需要把这些参数传递给真正需要执行的函数fn。最后的throttle函数如下：function throttle(fn, gapTime) {\r\n    if (gapTime == null || gapTime == undefined) {\r\n        gapTime = 1500\r\n    }\r\n\r\n    let _lastTime = null\r\n\r\n    // 返回新的函数\r\n    return function () {\r\n        let _nowTime = + new Date()\r\n        if (_nowTime - _lastTime > gapTime || !_lastTime) {\r\n            fn.apply(this, arguments)   //将this和参数传给原函数\r\n            _lastTime = _nowTime\r\n        }\r\n    }\r\n}再次点击按钮this和e都有了：参考轻松理解JS函数节流和函数防抖源代码tomfriwel/MyWechatAppDemo 的throttle页面"}
{"title": "“同住”小程序疑涉黄被下线，前车之鉴下共享床位为何屡禁不止 ... ", "author": "Rolan", "pub_time": "2018-1-26 00:02", "article_content": "在共享经济的风口里，永远不缺花样百出的“共享概念”。据中国之声《新闻纵横》报道，一款主打“酒店床位共享”的微信小 程序 “同住”悄然进入公众视野，号称自己是“全新的共享经济形态”，如果一个人预订了酒店的标间，空着的一张床就可以通过微信上的“同住”小程序进行分享。但在运营一段时间之后，1月25日，宣称“和TA一起睡，重返20岁”，主打“床位共享”的小程序“同住”，因涉嫌低俗、性暗示或色情信息，被微信官方叫停，已被下线。据悉，这款小程序在宣传推广时，曾发布过带有“房已开好快上车，还在用陌陌？”广告语的海报，以及主页显示“同性请AA，异性拼房男士应降价”，“黄金会员以上级别可享受异性拼房服务”等暧昧提示语，涉嫌鼓动黄色交易、传播黄色内容。更为疯狂的是，甚至有用户在个人信息处上传有色情意味照片，并备注自己的微信联系方式，目的显然是“一夜情”。而“同住酒店拼房”客服则解释称，“一夜情，其实 支付宝 可以一夜情，知乎也可以一夜情，就连 墨迹天气 都能一夜情，这个不是产品本身的设计，我们本身是分享”。有专家认为，该程序采用暗示性、倾向性的宣传语，并公开鼓励“异性拼房”，尽管并未明确违法，但有“擦边球”嫌疑，可能为涉黄活动提供平台，如果因此产生民事或刑事问题，平台也应承担连带责任。共享经济这两年在中国一直是最火的概念，以至于有国外网友把共享经济列为中国新四大发明之一。如果说，共享充电宝、共享雨伞这类的共享创新，还只是策略失当的话;那么“异性拼房”式的共享，就纯粹是策略失足了。很多伪创新搭着共享的东风，早就涌现了出来，当然也并没有避免被叫停的命运。2017年7月，在北京、上海等城市曾出现过刷爆朋友圈的“共享睡眠仓”，其属于一家叫“享睡空间”的公司，和共享单车一样采取扫描、计时和付费的流程，半小时收费为6元。在外型类似太空舱的睡眠舱内配置有恒温空调、小风扇、WI-FI和插座，入住的用户方可免费领取太空毯、一次性床单、一次性枕巾和湿纸巾等床品。舱内提供的床约为2米长、1.2米宽，仅容一人休息。据体验者反馈，睡眠舱内可以清楚地听到舱外的声音，隔音不是很好，并且，由于密闭性造成的空气流通不畅，使得舱内即便有换气扇，也无法做到空气特别清新。仅在一周之后，这种“共享睡眠仓”即被关停，据悉原因为没有获得消防 许可 ，以及未获得宾馆特种行业经营许可。同样在2017年的9月，著名情趣电商“他趣”推出了一个奇葩项目“共享女友”，其实为一个“租赁充气娃娃”项目。据了解，用户在线下单后支付8000元押金，即可以一天298元，或三天、一周、包月形式，租到据说价值上万元的充气娃娃。他趣提供香港、俄罗斯、希腊、韩国、天堂岛五种造型，还定制发型、肤色、加热、发声等，并配备服装和道具。充气娃娃派送、回收都由他趣上门服务。但是在短短的刷屏两天之后，被北京警方叫停，理由是“低俗活动扰乱社会治安”。警方在做出罚款决定后，还要求地推人员写下保证书，将充气娃娃带离北京。为什么在这些博人眼球、甚至有违法嫌疑的共享项目纷纷被叫停之后，反而有越来越多的人跃跃欲试，想要投身其中？新芽NewSeed（www.NewSeed.cn）认为，不外乎其背后的经济价值。首先，大量资本涌进所谓的风口，to VC型创业依然存在；其次，共享模式是成本较低、耗时较短的商业模式，为了尽快获利变现，很多项目都没有经过严密论证，就以共享模式仓促推向市场；再次，这些充满噱头的共享项目，本身就属于共享经济里的伪创新，其最大的目的还是想要引人注目，吸引大家的眼球，正如“共享女友”，其实项目方真正期待的是人们点开他们的网站，去购买产品。"}
{"title": "微信小程序之多列表的显示和隐藏功能（附源码） ", "author": "Rolan", "pub_time": "2018-1-27 00:32", "article_content": "今天在项目碰到一个问题，之前在项目首页实现单列表的显示和隐藏，通过wx:if判断就可实现，现在要实现多列表的单项显示和隐藏功能应该如何实现呢？如果还用wx:if实现的话会出现点击一个列表项，多个列表同时显示和隐藏，明显不适合功能需求，然后简单地查了资料也没发现有类似的功能，最后思考一番后，慢慢地理清了思路...效果图：显示和隐藏.gif 实现思路：实现单个列表的显示和隐藏应该使用唯一元素让程序知道你应该显示和隐藏哪个列表项，可以用数据的id； css中定义一个hidden{display：none}控制显示和隐藏，然后通过三元运算符来判断； wxml定义一个点击事件来动态修改这个列表项的变量值。 功能实现：好了，思路有了，就开始按照思路来用代码验证。果不其然，使用代码实现之后，发现自己的思路还是没错的。此功能点也可以应用到其它类似的列表的显示和隐藏中。示例代码：<!--pages/myOrder/myOrder.wxml--><view class='container'>  <!-- 订单列表 -->  <block wx:for-items=\"{{carInfoData}}\">    <view class='card  b-shadow' bindtap='toggleBtn' id=\"{{item.id}}\">      <view class='nearCard-fl'>        <image src='{{item.imgurl}}'></image>      </view>      <view class='nearCard-fr'>        <view>日期：          <text class='c-green'>{{item.useDate}}</text>        </view>        <view>车型：          <text class='c-green'>{{item.cx}}</text>        </view>        <view>时长：          <text class='c-green'>{{item.time}}</text>        </view>        <view>费用：          <text class='c-green'>{{item.feiyong}}</text>        </view>      </view>      <view class='down clearfix {{uhide==item.id?\"\":\"hidden\"}}'>        <view class='ml30'>启用时间：2018.01.01 11:33</view>        <view class='ml30'>结束时间：2018.01.01 11:33</view>        <view class='ml30'>租赁地区：舟山市桃花岛景区海湾浪琴</view>        <view class='feedBack'>意见反馈</view>      </view>    </view>  </block></view>// pages/myOrder/myOrder.jsPage({  /**   * 页面的初始数据   */  data: {    uhide: 0  },  /**   * 生命周期函数--监听页面加载   */  onLoad: function (options) {    var that = this;    var data = {      \"datas\": [        {          \"id\": 1,          \"imgurl\": \"../../images/car.png\",          \"useDate\": \"2017-12-22\",          \"cx\": \"奇瑞EQ1\",          \"time\": \"1小时\",          \"feiyong\": \"20元\"        },        {          \"id\": 2,          \"imgurl\": \"../../images/car.png\",          \"useDate\": \"2017-12-22\",          \"cx\": \"奇瑞EQ1\",          \"time\": \"1小时\",          \"feiyong\": \"20元\"        },        {          \"id\": 3,          \"imgurl\": \"../../images/car.png\",          \"useDate\": \"2017-12-22\",          \"cx\": \"奇瑞EQ1\",          \"time\": \"1小时\",          \"feiyong\": \"20元\"        },        {          \"id\": 4,          \"imgurl\": \"../../images/car.png\",          \"useDate\": \"2017-12-22\",          \"cx\": \"奇瑞EQ1\",          \"time\": \"1小时\",          \"feiyong\": \"20元\"        }      ]    };    //console.log(data.datas);    //设置车辆展示信息    that.setData({      carInfoData: data.datas    })  },  //点击切换隐藏和显示  toggleBtn: function (event) {     var that = this;    var toggleBtnVal = that.data.uhide;    var itemId = event.currentTarget.id;     if (toggleBtnVal == itemId) {      that.setData({        uhide: 0      })    } else {      that.setData({        uhide: itemId      })    }   }})GitHub源码地址：小程序显示和隐藏"}
{"title": "小程序支持打开移动应用到底是怎么回事？ ", "author": "Rolan", "pub_time": "2018-1-29 00:12", "article_content": "从苹果官方微信号 微信公共平台 发布的文章 《小程序支持打开移动应用》 来看，小程序新增了两个功能：支持打开移动应用标题栏区域开放自定义针对第二个功能，就是开发者可以自定义小程序菜单栏的颜色风格，根据需求，对小程序菜单外的标题区域进行自定义，比如设置标题区域的颜色。这里主要介绍一下支持打开移动应用的功能。支持打开移动应用乍一看其实有点标题党的行为，支持打开移动应用？让我想到的是我可以用小程序打开任何移动应用？（答案是不能）那我是不是可以打开自己的App？（答案是有限制性地打开）是不是可以打开系统自带的浏览器？（答案是不能）是不是可以打开第三方的移动应用呢？（答案也是不能）其实，小程序打开移动应用有一条硬性要求： 从移动应用分享至小程序的页面，用户访问时支持打开来源应用。 接下来进一步解读一下这条要求。大部分程序都有微信分享功能，我们常做的就是将一个图片、一段文字亦或是一个URL链接进行分享，可以分享给好友（包括群）、朋友圈或者是添加到个人收藏，如下：我们还可以分享小程序，如图：上面是一个抢票软件（智行）分享到微信的一个小程序，好友可以点击小程序帮忙加速。按照官方文章的说法，分享到微信的小程序里面如果有一个按钮，实现如下：<buttonopen-type=\"launchApp\"app-parameter=\"wechat\"binderror=\"launchAppError\">打开APP</button>\r\n那么当点击此按钮时，就会打开源App。在其他情况下是无法打开的，这里给出了一张能否打开移动APP的图解：这里小程序给出一个场景值概念，只有场景值为1036（还有个状态值true或false，它决定是否能够打开APP。场景值为1036，状态值为true）的小程序，才能够打开源APP，即 小程序不能打开任何App，只能跳回分享小程序卡片的APP 。官方文档也对这个标识做了解释：在小程序的生命周期内，这个状态的初始值为 false，之后会随着小程序的每次打开（无论是启动还是切到前台）而改变：1.当小程序从 1036（App 分享消息卡片） 打开时，该状态置为 true。2.当小程序从 1089（微信聊天主界面下拉）或 1090（长按小程序右上角菜单唤出最近使用历史）的场景打开时，该状态不变，即保持上一次打开小程序时该状态的值。3.当小程序从非 1036/1089/1090 的场景打开，该状态置为 false。针对第二条，1089和1090那个，我的理解是小程序类似于移动APP，它并没有关闭，而是在后台，所以1089和1090打开小程序只是把小程序唤到前台，所以小程序状态不变。状态如果为true，也可以打开移动APP。以上便是对小程序打开移动应用的介绍，接下来看一下具体代码实现。代码实现分享小程序打开移动应用（iOS版本，Android类似）首先要做的就是新建一个工程，然后集成微信分享，具体如何集成可以参见 官网集成文档 ，集成之后，在页面添加一个按钮，触发实现如下：- (IBAction)openSmallProgramAction:(id)sender {\r\n    //分享小程序的实现\r\n    WXMiniProgramObject *wxMiniObject = [WXMiniProgramObject object];\r\n    wxMiniObject.userName = @\"gh_*************\";\r\n    wxMiniObject.path = @\"pages/index/index\";\r\n\t//\r\n    WXMediaMessage *message = [WXMediaMessage message];\r\n    message.title = @\"我是小程序\";\r\n    message.description = @\"我是用来测试打开App的小程序\";\r\n    message.mediaObject = wxMiniObject;\r\n    \r\n    SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init];\r\n    req.message = message;\r\n    req.scene = WXSceneSession;\r\n    [WXApi sendReq:req];\r\n   //原来做分享的实现\r\n//    SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init];\r\n//    req.text = @\"分享的内容\";\r\n//    req.bText = YES;\r\n//    req.scene = WXSceneSession;\r\n//    [WXApi sendReq:req];\r\n}\r\n这里是所有的App都可以用上面的实现方式分享小程序么吗？答案是否定的。看官方文档的说法：移动应用分享功能支持小程序类型分享，要求发起分享的APP与小程序属于同一微信开放平台帐号。支持分享小程序类型消息至好友会话，不支持“分享至朋友圈”及“收藏”。也就是说小程序分享是有限制的：发起分享的App与小程序属于同一微信开放平台账号只支持分享小程序类型消息至好友会话（SendMessageToWXReq的scence只支持WXSceneSession）经过测试，一个账号不能同时注册 微信开放平台 和 微信公众平台 。也就是说：如果你的账号注册了微信开放平台，那么该账号就不能再次注册微信公众平台。微信开放平台放的是移动APP。微信公众平台放的是小程序。那官方所说的属于同一微信开放平台账号就不是一个账号下既有APP又有小程序（因为小程序是在微信公众平台开发的）。打开微信开放平台页面之后，第一条就好理解了：如果你想要在移动APP内分享小程序，你必须在该APP所在的微信开放平台账号下绑定微信小程序，这样才可以在APP中实现小程序分享。这就是官方所说的APP和小程序属于同一微信开放平台账号。那么APP怎么知道分享哪个小程序的？ 或者说APP是怎么和小程序关联的呢？这就要看上面的那段代码（前提是你把小程序和APP放到了同一开放平台账号下），其中有一行：wxMiniObject.userName = @\"gh_*************\";\r\n该userName就是小程序的userName，你可以登录 微信公众号平台|小程序 ，然后在设置—>基本设置中查看，里面有个原始id，就是小程序的userName。这样你就将APP的分享和小程序关联起来了。还有一个问题： 分享的小程序如何打开指定的页面呢？这就要看另一行代码：wxMiniObject.path = @\"pages/index/index\";\r\n你需要设置一下小程序的path，这个path的页面就是你点击分享的小程序打开的页面。这里看一张小程序开发工具的图：pages所指的就是页面，例如上图的pages文件夹包含了detail和index和logs三个页面，其中：index：指代的是信用卡列表页。detail：指代的是点击列表某个item进入的详情页。logs：日志页面所以如果你想跳转到详情页，那么你在设置wxMiniObject的path时就应该写成“pages/detail/detail”。这样就实现了点击分享的小程序进入指定的页面了（如果页面需要参数你也要在分享时传过去）。wxml：相当于htmlwxss：相当于css这里其实是微信小程序自己定义了后缀。这个时候你分享的小程序场景值为1036，且状态为true，如果此时你小程序里面有open-type为“launchApp”的button，点击button你就会跳回你的移动APP啦。如果想给APP回传内容，可以设置app-parameter。就像这个小按钮：<button open-type=\"launchApp\" app-parameter=\"wechat\" binderror=\"launchAppError\">打开APP</button>到此，我想你应该大概了解小程序支持打开移动应用到底是怎么回事了。总结小程序并不是支持打开所有移动APP，就算是同一个微信开放平台账号下面的移动APP和小程序，小程序也不一定可以打开，具体还要看场景。展望小程序支持跳转移动APP是很大的进步，在小程序以后的进一步完善中，它应该会朝着APP直接打开小程序方向迈进，而不仅仅是通过分享打开小程序。未来我们也许会实现点击移动APP里面的某个按钮直接打开某个小程序，然后在小程序操作完成之后再次返回到移动APP。（例如微信支付，可以从移动APP跳转到小程序进行微信支付，支付成功后直接返回移动APP）"}
{"title": "小程序内置组件swiper，circular（衔接）使用小技巧 ", "author": "Rolan", "pub_time": "2018-1-19 00:24", "article_content": "swiper，关于滑块的一些效果无缝，断点，视差等等...我想这里就不用做太多的赘述，这里给大家分享一下实战项目中使用circular（衔接）的一点小特性、小技巧，当然你也可以理解为遇到了一个小坑，因为不能把整个项目搬上来，所以这里用一个小事例去简单的描述一下。功能介绍swiper滑块视图容器（轮播效果）可配置项这里只简单列出示例中所需的一些属性，如需了解更多 【请点击，了解更多详情】indicatorDots: true, //  是否显示面板指示点\r\n    autoplay: false, // 是否自动切换\r\n    circular: true, // 是否采用衔接滑动\r\n    current: 0, // 当前所在页面的 index\r\n    interval: 500, // 自动切换时间间隔\r\n    duration: 500 // 滑动动画时长\r\n示例场景类答题效果，答对本题自动跳转下一题，并保持滑块的衔接效果（这里我们用按钮来代替自动跳转）WXML：<page>\r\n        <view class='wrap-swiper'>\r\n          <swiper indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\" circular=\"{{circular}}\" current=\"{{current}}\" bindchange='testDetails' indicator-active-color='#fff'>\r\n            <block wx:for=\"{{imgUrls}}\" wx:key=\"key\">\r\n         <swiper-item>\r\n           <image src=\"https://user-gold-cdn.xitu.io/2018/1/15/160f8b440965adf5\" class=\"slide-image\" width=\"355\" height=\"150\" />\r\n         </swiper-item>\r\n            </block>\r\n          </swiper>\r\n          <view class=\"wrap\">\r\n           <button bindtap='nextPage'>跳转下一题</button>\r\n          </view>\r\n        </view>\r\n</page>\r\nWXSS：swiper{\r\n  width: 80%;\r\n  margin: 0 auto;\r\n  margin-top: 20%;\r\n  padding-top: 25px;\r\n}\r\n.wrap{\r\n  display: flex;\r\n  justify-content: space-around;\r\n  margin-top: 25px;\r\n}\r\n.wrap-swiper{\r\n  background: rgba(0,0,0, 0.1) ;\r\n  padding-bottom: 25px;\r\n  margin-left: 15px;\r\n  margin-right: 15px;\r\n}\r\nJS:Page({\r\n  data: {\r\n    imgUrls: [\r\n      'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg',\r\n      'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg',\r\n      'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'\r\n    ],\r\n    indicatorDots: true, //  是否显示面板指示点\r\n    autoplay: false, // 是否自动切换\r\n    circular: true, // 是否采用衔接滑动\r\n    current: 0, // 当前所在页面的 index\r\n    interval: 500, // 自动切换时间间隔\r\n    duration: 500 // 滑动动画时长\r\n  },\r\n  testDetails (e) {\r\n    // bindchange事件\r\n    console.log(e)\r\n  },\r\n  nextPage () {\r\n    // 跳转下一题\r\n     let current = this.data.current\r\n     current++\r\n     if (current > 2) {\r\n      current = 0\r\n     }\r\n  }\r\n})\r\n运行效果:对比通过上述，首先我们看到，当我们左右滑动时候，衔接效果是没有毛病的，但是当我们去模拟跳转的时候，问题出现了，衔接失效？这究竟是怎么回事呢？现在我们就来看一下在bindchange事件（testDetails）的两次log中发生了什么？问题如上图所属，source（来源） 出现问题，模拟跳转改变current方式改变了内部衔接跳转的机制，那既然知道原因，那下一步的就要考虑如何模拟swiper内部的机制动作，那又该如何模拟呢？就要从autoplay这个内置属性操刀了，废话不说直接上代码！JS（修改后）小特性： 主动触发swiper的autoplay特性，检测bindchange事件的source来源，做动态动态关闭处理Page({\r\n  data: {\r\n    imgUrls: [\r\n      'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg',\r\n      'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg',\r\n      'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'\r\n    ],\r\n    indicatorDots: true, //  是否显示面板指示点\r\n    autoplay: false, // 是否自动切换\r\n    circular: true, // 是否采用衔接滑动\r\n    current: 0, // 当前所在页面的 index\r\n    interval: 500, // 自动切换时间间隔\r\n    duration: 500 // 滑动动画时长\r\n  },\r\n  testDetails (e) {\r\n    console.log(e)\r\n    if (e.detail.source == 'autoplay') {\r\n      this.setData({\r\n        autoplay: false\r\n      })\r\n    }\r\n  },\r\n  nextPage () {\r\n    // 跳转下一题\r\n    this.setData({\r\n      autoplay: true\r\n    })\r\n  }\r\n})\r\n对比log（修改后）运行效果（修改后）跑起来瞅一眼总结本篇文章更多的是对于一些用法的分享，简单的特性说明，更深层次的内容，有兴趣的道友还是可以去研究下的，另外欢迎大家关注点赞，多谢！（持续更新中...）（注：封面来源于互联网，如有侵权，请联系作者删除；如需转载，请附原文链接及署名，多谢）"}
{"title": "揭密微信跳一跳小游戏那些外挂 ", "author": "Rolan", "pub_time": "2018-1-19 00:30", "article_content": "作者：Hahn， 腾讯高级UI工程师商业转载请联系腾讯WeTest获得授权，非商业转载请注明出处。 原文链接：http://wetest.qq.com/lab/view/364.htmlWeTest 导读张小龙：这个游戏发布以后，其实它的效果有点超出我们的预期，我们自己开玩笑说，这个游戏突然变成了有史以来可能用户规模最大的一个游戏，因为它的DAU大概到了1点几亿，但同时出现了很多外挂，我没有想到这么小的一款游戏也会有那么多外挂，我朋友圈的朋友也打出了特别高的分，但是我相信不是他自己打出来的。1 月 15 日微信在广州召开 2018 年的微信公开课 Pro，张小龙不仅当场玩了一把跳一跳游戏并取得了900多的高分，还特别提到了跳一跳小游戏的外挂：在跳一跳这样一个小的游戏里面，如果一个用户看到里面有一堆外挂得了很高的分，对其他一些每天在练习，试图把自己的水平提高，而打一个高分的人就很不公平，他可能就没有动力继续去练习，继续超越自己个人的最高分数。所以这样一个行为，外挂行为其实会破坏整个系统的规则，并且让规则立即变得失效。所以，我们这个小游戏发布以后，我们就开始花了很多很多时间来打击外挂。本着钻研技术的学习态度，我对目前几款比较火的外挂进行了源码分析，总结出了它们的一些破解思路，其实这些作者都并非恶意，作为一个程序员，还有什么比用技术挑战规则，突破极限要有成就感呢？一、梳理跳一跳的游戏可以细分为两步骤：距离判断 + 按压模拟，这两步都有下面这些解决方案：1、距离判断：● 简单方案：像素点判断● 进阶方案：OpenCV 图像分析2、按压模拟：● 简单方案：adb/wda 指令● 进阶方案：机械臂模拟手指点击（原创）下面逐一介绍这里的实现方法，非常有意思。二、距离判断1. 像素点判断该方法采用自目前最火的跳一跳小游戏「辅助程序」：wechat_jump_game。如上图所示，我们先定义了「棋子」和「棋盘」，需要找到的两个目标点用橙色点标注，首先针对棋子的目标点的判断，可以这么做：相关代码：而针对棋盘中心点的确认的思路则是这样的：当然还有一些其他方法来尽量缩小棋盘中心点的检测区域，这里简单介绍下：当然，如果恰好跳到中心点，下一个棋盘中间会有白色点，则可以直接匹配中心点的色值，得到棋盘中心点，这种情况基本百发百中：相关代码：但棋盘种类比较多，形状也各异，而且棋盘表面并非纯色，还有其他颜色，所以即使像素判断的代码里增加了很多特殊 case，依旧不能做到非常完美：总结一下，目前这个方案基本没有太大问题，但如果跳一跳游戏把背景改成了非线性渐变，或随机飘落一些物体，或棋盘表面更加复杂，那这里的算法就基本不可用了。2. OpenCV 图像分析基于像素点的判断低效而且不够健壮，而利用 OpenCV 计算机视觉库则可以从图像分析层面进一步简化判断逻辑提升效率，首先采用该方法的跳一跳小游戏「辅助程序」来自 wechat_jump_jump。它是这么得到棋子的位置的：相关代码：接下来找棋盘的中心点，假如下一个棋盘存在白色的示意点，同样采用上面的模板匹配方法进行匹配，若匹配不上（匹配值小于某阈值，也许下个棋盘本身就是白色，所以灰度图分辨不出），则采用第二种方案：这里是否准确的精髓就在于高斯滤波去除图像噪音的临界点以及 Canny 函数中阈值的设定，需要不断调整参数到最优状态。相关代码：三、按压模拟1. adb/wda 指令这两个分别是针对 Android 和 iOS 的命令行工具，可以将手机和电脑连接起来，并通过命令行发送指令，指令中就包含了屏幕的截图和按压模拟。不过 iOS 配置起来稍微麻烦一点，具体操作指引可以参考 这里。其核心的命令有：当然，如果嫌配置麻烦，还可以通过 Android 的 AirDrop App 或 iOS 的 QuickTime 把手机屏幕投到电脑中，然后通过 Python 的 Pillow 库来截取投屏的内容，再做进一步的图像识别工作。还有一点值得一提，按压时间这部分还是有优化的空间，前面提到了跳跃距离和按压时间基本是线性关系，但越到后面可以越发现，距离并非和按压时间绝对成线性比例，因为游戏本身不是一个纯 2D 的平面场景（2.5D），所以我们测量到的直线距离在 2.5D 场景中是有变化的，虽然影响不大，但在游戏后期棋盘越来越小，距离越来越大时，容易凸现出问题来，所以关于距离的计算有几种不同的解决：拟合函数的细节可以参考：1）https://github.com/metowolf/JumpJumpHelper2）https://github.com/wangshub/wechat_jump_game/issues/7443）https://github.com/wangshub/wechat_jump_game/pull/8412. 机械臂模拟手指点击本着学术探究的态度，结合之前折腾开源硬件的经历，所以也斗胆想给跳一跳小游戏增加一点动手环节，把触摸模拟这一操作通过机械臂来物理完成，于是在万能淘宝里淘了一个一百多快钱的机械臂和部分配件，自己编写了控制代码，把按压时间传输作为机械臂按下的停留时间，想法确定后便开始购置物品：到货后折腾一两个晚上，最后成功搭建好了，大家看看效果（电容笔偶尔还是会触碰不良）视频链接：https://v.qq.com/x/page/s0532...四、最后反对一切使用外挂行为！反对一切使用外挂行为！反对一切使用外挂行为！通过对外挂程序源码的研读，学习到了非常多创新的思维，这也算是外挂留给代码世界的果实。关于腾讯WeTest手游安全测试团队腾讯WeTest手游安全测试团队从2011年初开始对手游安全领域进行探索和技术积累，旨在通过提前发现游戏版本的安全漏洞，预警风险，打造出业界领先的手游安全测试技术方案，在工具上已经支持所有腾讯在研和运营的手游项目。团队通过使用与正式服同样的游戏客户端和服务器，模拟外挂工作室制作外挂的过程，依靠自身的技术积累来提高专业程度，持续保持漏洞的发现率。目前提供了专家测试服务，希望通过提前发现游戏版本的安全漏洞，预警风险，帮助提高腾讯游戏的品牌和口碑。服务目前已经对外开放，点击http://wetest.qq.com/product/sr 即可使用"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "article_content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序爬坑日记 ", "author": "Rolan", "pub_time": "2017-12-11 00:24", "article_content": "新公司上手小程序。30天，从入门到现在，还没放弃。。。虽然小程序发布出来快一年了，爬坑的兄弟们大多把坑都踩平了。而我一直停留在“Hello World”的学习阶段。一来没项目，只有项目才是实践学习的根本；二来刚出来，总是有很多坑。爬坑总是痛并快乐着。再多的借口，产品项目需求拍在桌前，都得缴械投降。不要怂撸起袖子，就是干。初识小程序微信推出小程序，想要实现即开即用，用完即走的用户体验。免去APP下载安装繁琐的流程。听起来像谷歌推出的PWA，不过PWA普及到国内还有段时间。而小程序借助于微信的用户群体，植入成本低，容易被用户接受。小程序的代码风格跟Vue其实挺像，对于习惯Vue开发模式的同学，上手并没有太大的问题。小程序不支持前端主流框架，如Vue，Angular，React，jQuery等，而且小程序有自己的一套视图容器(Dom)的写法，跟平常我们在web上写HTML不一样。不过CSS3那些变化不大。虽然文件名改成了(.wxss)本司项目，使用webpack做打包工具，将代码编译成符合小程序的代码目录规范，采用wechat-mina-loader插件，实际开发起来跟在Vue下开发习惯一样。babel完成ES6转ES5，sass编译，压缩转化等工作都放到webpack中去做。不支持dom操作小程序脚本内不能使用window,document对象，所以无法操作dom。如果想操作节点，可用wx.createSelectorQuery()另外数据驱动的开发模式，跟Vue相同，只是写法换了（vue: v-if，小程序: wx:if）rpx布局rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。设计师做设计图以iPhone6作为设计稿基准就可以，基本上可以用rpx替换px，不过在一些表单或者提示页面，使用设计稿上的rpx会让小屏幕手机看着尺寸略小，提示页面可参照weui用px来实现路由层级wx.navigateTo(OBJECT)保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面wx.redirctTo(OBJECT)关闭当前页面，跳转到应用内的某个页面wx.switchTab(OBJECT)跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面wx.reLaunch(OBJECT)关闭所有页面，打开到应用内的某个页面小程序只能同时打开打开5个页面，当打开5个页面后，wx.navigateTo不能正常打开新页面，请避免多层级的交互方式，或者使用wx.redirctTo重定向tabBar底部导航栏tabBar是一个数组。配置最少2个，最多5个，tab数组按顺序排序页面滚动到顶部基础库1.4.0支持wx.pageScrollTo({\r\n  scrollTop: 0   //滚动到页面的目标位置（单位px）\r\n})图片资源，CSS中的背景图片CSS中无法使用本地资源(开发目录中)的图片作为background-image。可以使用网络图片资源，或base64，或者使用image标签。tabBar的icon资源可使用本地资源unionid与openid的区别每个用户在每个小程序里面都有唯一的openid，如果想在多个公众号，小程序里面共享用户信息，统一识别该用户，则需要用到unionid。为了获取uniond则需要注册微信开放平台，将需要共享的小程序，公众号进行绑定（不超过10个，超过10个还要申请认证称为第三发平台）。textarea在滚动页面中的bugtextarea,map等组件是由客户端创建的原生组件，它的层级是最高的。如果有遇到定位元素的话。永远在最上面，盖不住。请勿在 scroll-view、swiper、picker-view、movable-view 中使用 textarea 组件CSS动画对textarea无效项目场景：页面底部固定了一个按钮（position:fixed), 页面滚动时，textarea总是在按钮上面，点击按钮就点到了textarea可以设置网络请求的超时时间app.js中配置\"networkTimeout\": {\r\n  \"request\": 10000 // 10秒\r\n}window配置navigationBarTextStyle 导航栏标题颜色仅支持black/white状态栏，导航条，标题，窗口背景色支持纯色，不支持渐变色参数问题url中添加参数，如url?a=1&b=2, onLoad(options) options.query.a, options.query.b可获取到扫描小程序码进页面，如果想获取小程序码url中所带的参数，可通过options.scene获取，不过需要对二维码中的scene值进行转换decodeURIComponent(options.scene), 调试阶段可以使用开发工具的条件编译自定义参数 scene=xxxx 进行模拟，开发工具模拟时的 scene 的参数值需要进行 urlencode (启动参数：scene=n%3D1001) 实际为scene=n=1001，参数n=1001image标签图片image默认width: 300px, height: 225px, lazy-load懒加载只对page与scroll-view下的image有效mode缩放模式，mode=\"widthFix\"比较常用(宽度不变，高度自动变化，保持原图宽高比不变)小程序可以监听小程序的关闭后，但是无法阻断场景：想在小程序退出时弹出个提示框，并阻止关闭（暂时无法实现）小程序码小程序码(葵花码)有几种方式，只有发布过小程序才可正常显示小程序码小程序第一次提交的审核时间较后面的长第一次提交审核一般1天到2天。所以为了能准点上线，建议先上一次临时的版本(放一个提示页面都可以)，过了第一次审核发布再说。日常提交审核，2-3小时就可以。频繁地setData会造成性能问题频繁地setData操作，会出现卡顿，操作反馈延迟严重，甚至有可能闪退。场景：原计划用countUp做数字动画，原理就是频繁地改变数字值，setData操作，渲染到模版上。ES6转ES5，小程序检测目录中的js文件(极少)项目中用了webpack进行ES6转ES5，所以关闭了微信小程序的ES6转ES5功能。这个坑就比较隐蔽了，测试的时候在5S真机上报js错误，发现有个js(使用了ES6，没有转ES5)文件没有使用，微信小程序会去检测目录中的js文件，如果关闭了微信自带的ES6转ES5，检测到目录中js文件不兼容ES5，就报错。这个Bug只在5S真机里出现过，5C都正常。如果开启了微信开发工具中的ES6转ES5，则会自动帮你完成转化工作，不会出现类似问题。分享些小程序开发比较常用的第三方库weui-wxss(小程序版的weui样式库) Github: https://github.com/Tencent/weui-wxsswepy(小程序组件化框架) Github: https://github.com/Tencent/wepyskyvow/vux(小程序组件库) Github: https://github.com/skyvow/wuxxiaolin3303/wx-charts(小程序图标) Github: https://github.com/xiaolin3303/wx-charts"}
{"title": "小程序开发 - webview ", "author": "Rolan", "pub_time": "2017-12-14 00:29", "article_content": "最近要做一个项目需要在小程序中打开外链，小程序最近开放了web-view组件， 可在里面内嵌自己写的H5页面，也就实现了打开外链的功能，但是有几个注意点。 这里记录一下，希望将来小程序能放开更多限制。申请业务域名首先必须在小程序后台配置业务域名，并且是已经备案过的。微信授权登录当需要微信授权登录的H5页面直接通过小程序webview访问时，会报错。解决方案：对浏览器进行判断，如果是小程序webview（官方判断条件： window.__wxjs_environment === 'miniprogram' ）就跳过授权登录。 这样就规避了访问非授权业务域名问题。打开网页条件小程序基础库版本要大于 1.6.4，低版本的小程序需要做兼容处理网页内容只能在 组件中显示，它会自动铺满整个小程序页面个人类型与海外类型的小程序暂不支持使用web-view组件打开网页示例代码<!– wxml –>\r\n<!– 指向微信公众平台首页的web-view –>\r\n<web-view src=”https://mp.weixin.qq.com/”>web-view>\r\nweb-view组件接口网页中可使用JSSDK 1.3.0提供的接口返回小程序页面，支持的接口有：示例代码：\r\n<script type=\"text/javascript\" src=\"https://res.wx.qq.com/open/js/jweixin-1.3.0.js\">script>\r\n\r\n// javascript\r\nwx.miniProgram.navigateTo({url: '/path/to/page'})\r\n网页中仅支持以下JSSDK接口有限，详细请参考 官网文档说明"}
{"title": "【小程序踩坑系列】小程序退出后扫码再进入，“外部”代码不会再次执行 ... ", "author": "Rolan", "pub_time": "2017-12-19 00:22", "article_content": "作者: 蒋欢\r\n问题：\r\n小程序退出后再次扫码进入，只会执行生命周期函数里的代码，“外部”代码不会再执行。\r\n具体描述：\r\n在我们的项目里，我们会将一部分本地变量不写在小程序 pageConfig 的 data 中，而直接在文件头进行声明。这样是为了减少 data 的大小，加快页面渲染速度。但这也无意中带来了新问题，我们看看下面的例子。\r\n出错的index.js文件：\r\n    const localFlag = true; // “外部”代码，仅执行一次初始化，第二次扫码不会执行！\r\n\r\n    const pageConfig = {\r\n        data: {\r\n            text: 'init data'\r\n        },\r\n        onLoad(this, p) {  \r\n            console.error(\"localFlag默认为：\"， localFlag);\r\n\r\n            // Do something you need...\r\n            localFlag = false;\r\n        }\r\n    }\r\n\r\n    Page(pageConfig);\r\n按照以上代码运行，用户初次扫码时，localFlag的值为true。可是，当用户退出小程序，再次扫码进入时，localFlag没有再初始化，而为false了。如下图所示：\r\n\r\n如何避免上述情况的出现呢？\r\n其实也很简单，就是在文件头部只做本地变量声明，而不做定义。将定义部分放在生命周期函数（如：onload）内。具体代码如下：\r\n正确的ndex.js文件：\r\n    const localFlag; // 只做变量声明而不定义\r\n\r\n    const pageConfig = {\r\n        data: {\r\n            text: 'init data'\r\n        },\r\n        onLoad(this, p) {  \r\n            localFlag = true;\r\n            console.error(\"localFlag默认为：\"， localFlag);\r\n\r\n            // Do something you need...\r\n            localFlag = false;\r\n        }\r\n    }\r\n\r\n    Page(pageConfig);\r\n如此，每次进入页面 localFlag 都会被置为 true 了。\r\n环境：\r\nIOS 和 安卓 均可稳定复现。\r\n原因：\r\n这看起来属于小程序自身的模块设计方式导致的。推测即使退出小程序，之前打开的页面也没有做到真正卸载，而处在内存之中。下次再次进入同一个页面时，会被唤起。\r\n解决方案：\r\n只在头部代码进行本地变量声明，而不定义。将本地变量的定义放在生命周期函数中去。\r\n风险：\r\n属于小程序开发的经验积累相关。"}
{"title": "五分钟掌握微信小程序轮播图 ", "author": "Rolan", "pub_time": "2017-12-25 00:07", "article_content": "微信小程序轮播图实现，比Android 轮播图来说，显得轻松多了。微信小程序提供swiper组件，官网api提供的swiper滑块视图容器。\r\n从公共库v1.4.0开始，change事件返回detail中包含一个source字段，表示导致变更的原因，可能值如下：\r\nautoplay 自动播放导致swiper变化；touch 用户划动引起swiper变化；其他原因将用空字符串表示。\r\n注意：其中只可放置组件，否则会导致未定义的行为。\r\nswiper-item\r\n仅可放置在组件中，宽高自动设置为100%。\r\nindex.wxss\r\nswiper {    height: 421.5rpx;}swiper-item image {    width: 100%;    height: 100%;}.swiper-container{  position: relative;}.swiper-container .swiper{  height: 300rpx;}.swiper-container .swiper .img{  width: 100%;  height: 100%;}\r\nindex.js\r\nPage({  data: {    swiperCurrent: 0,    indicatorDots: true,    autoplay: true,    interval: 3000,    duration: 800,    circular:true,    imgUrls: [      'https://p3.pstatp.com/large/43700001e49d85d3ab52',      'https://p3.pstatp.com/large/39f600038907bf3b9c96',      'https://p3.pstatp.com/large/31fa0003ed7228adf421'    ],    links:[      '../user/user',      '../user/user',      '../user/user'    ]  },  //轮播图的切换事件  swiperChange: function (e) {    this.setData({      swiperCurrent: e.detail.current    })  },  //点击指示点切换  chuangEvent: function (e) {    this.setData({      swiperCurrent: e.currentTarget.id    })  },  //点击图片触发事件  swipclick: function (e) {    console.log(this.data.swiperCurrent);    wx.switchTab({      url: this.data.links[this.data.swiperCurrent]    })  }})\r\nindex.wxml\r\nclass=\"swiper-container\">  <swiper indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\" circular=\"{{duration}}\" current=\"{{swiperCurrent}}\" bindchange=\"swiperChange\" class=\"swiper\">    <block wx:for=\"{{imgUrls}}\" wx:key=\"unique\">      <swiper-item>        <image src=\"{{item}}\" class=\"img\" bindtap=\"swipclick\" />      swiper-item>    block>  swiper>view>\r\n重要一点是图片的点击事件，官网没明确指出。bindtap=\"swipclick\"\r\n swipclick: function (e) {    console.log(this.data.swiperCurrent);    wx.switchTab({      url: this.data.links[this.data.swiperCurrent]    })  }\r\n效果图"}
{"title": "微信小程序 引入公共页面的几种情况 ", "author": "Rolan", "pub_time": "2017-12-28 00:43", "article_content": "1、不带参数\r\n首先在pages文件夹中新建一个template文件夹，文件夹中新建一个template.wxml文件，代码如下\r\n<template name=\"msgItem\">  <view>    <text>This is template.wxml文件，我是一个模板text>  view>template>\r\n然后我们书写我们所要调用template的页面index.wxml\r\n<import src =\"../template/template.wxml\"/>　　<view>This is index.wxmlview><template is=\"msgItem\"/>\r\n注意：\r\n（1）index.wxml中template 标签的is属性与template.wxml中template 标签的name属性值相同\r\n（2）index.wxml文件中要通过import标签声明需要使用的模板文件\r\n运行效果：\r\n2、带参数\r\n首先，修改template.wxml文件，我们给模板添加三个字段，修改后代码如下\r\n<template name=\"msgItem\">  <view>    <text>This is template.wxml文件，我是一个模板text>    <view>      <text> {{index}}: {{msg1}} text>      <text> {{msg2}} text>    view>  view>template>\r\n接下来我们在index.wxml中传递模板中所需要的三个参数，修改后的代码如下：\r\n<import src =\"../template/template.wxml\"/><view>This is index.wxmlview><template is=\"msgItem\" data=\"{{index:1,msg1:'msg1数据',msg2:'msg2数据'}}\"/>\r\n运行效果： \r\n3、列表item模板\r\n接下来我们就通过一种常见的情况列表数据来使用模板，增加对模板的认知，直接上修改过的代码：\r\n//index.jsPage({  data: {    list:[      { name: '张三', age: 15 },      { name: '李四', age: 25 },      { name: '王五', age: 18 },      { name: '赵六', age: 19 },    ]  }})\r\n<import src =\"../template/template.wxml\"/><view>This is index.wxmlview><view wx:for=\"{{list}}\">    <template is=\"msgItem\" data=\"{{name:item.name,age:item.age}}\"/>view>\r\n<template name=\"msgItem\">  <view>    <text> name: {{name}} text>    <text> age: {{age}}text>  view>template>\r\n运行效果： \r\n4、使用模板样式\r\n接下来我们就给模板增加样式文件，然后在需要调用模板的地方使用该样式。 \r\n首先在pages/template文件夹中新建一个template.wxss文件,然后对模板文件，添加一个简单样式。\r\n<template name=\"msgItem\">  <view class=\"template_style\">    <text> name: {{name}} text>    <text class=\"template_age_style\"> age: {{age}}text>  view>template>\r\n/* pages/template/template.wxss */.template_style{  border-bottom: solid 2px #999999;  padding: 5px;  font-size: 18px;  color: #000000;}.template_age_style{  color: #666666;  font-size: 14px;}\r\n我们的样式文件已经创建好了，接下来在index.wxml中引入该样式文件。\r\n/index.wxss/@import \"../template/template.wxss\";运行效果： \r\n5、调用不同的模板\r\n有时候，我们有这样的需求，那就是同一个列表中，item数据不同，可能他的样式也是有很大的区别，所以我们使用的模板也会对应不相同，接下来我们就来实现这样需求的小Demo: 首先修改了一下template.wxml，原本该文件中只有一个template，现在我们创建了两个，新增的template仅仅多了一行代码，当然了实际开发中，需求会比这个难很多，在这里只是为了实现Demo。\r\n<template name=\"msgItem\">  <view class=\"template_style\">    <text> name: {{name}} text>    <text class=\"template_age_style\"> age: {{age}}text>  view>template><template name=\"msgItem2\">  <view class=\"template_style\">    <text> name: {{name}} text>    <text class=\"template_age_style\"> age: {{age}}text>    <text>我是一个未成年text>>  view>template>\r\n接下来我们在index.wxml中通过age字段调用不同的模板：\r\n<import src =\"../template/template.wxml\"/><view>This is index.wxmlview><view wx:for=\"{{list}}\">    <template is=\"{{item.age >= 18 ? 'msgItem' : 'msgItem2'}}\" data=\"{{name:item.name,age:item.age}}\"/>view>\r\n运行效果："}
{"title": "一次不成功的深度学习实践 - 微信跳一跳 ", "author": "Rolan", "pub_time": "2018-1-3 00:27", "article_content": "最近微信的跳一跳小程序火了一把，所以前天也更新了微信玩了几盘，最多手动到200左右就不行了。后来准备用代码写个辅助工具，上Github一查，已经有人做出来了，17年12月29号的项目，不到5天差不多5K的stars，以后还会更多，简直可怕。github.com/wangshub/we…具体思路都差不多：用adb调试手机，获取截图；从截图中识别棋子和目标块的中心点位置；根据距离计算长按时间，系数和屏幕分辨率相关；用adb模拟长按，完成跳跃。唉，多么可惜，错过了一个好项目。既然别人已经实现了，那就尝试点不一样的，用 深度学习 解决一下。基本思路基本流程类似，唯一的区别在于如何获取棋子和目标块的中心位置。假如长按时间只取决于棋子和目标块的水平位置，那么只需要知道它们水平方向上的坐标即可。可以看作一个 物体检测 问题，检测出截图中的棋子等物体，这里假设共包含七类物体：棋子：chess彩蛋块：包括污水 waste、魔方 magic、商店 shop、音乐盒 music普通块：包括矩形块 rect、圆形块 circle模型实现我手动标注了500张截图，基于ssd_mobilenet_v1_coco模型和TensorFlow物体检测API，训练好的模型跑起来是这么个结果。可以看到截图中的棋子、魔方、矩形块、圆形块都被检测了出来，每个检测结果包括三部分内容：物体位置，用矩形标注，对应四元组 ymin、xmin、ymax、xmax；物体类别，为以上七类中的一种；检测置信度，越高说明模型对检测结果越有把握。这不仅仅是简单的规则检测，而是 真正看到了截图中共有哪几个物体，以及每个物体分别是什么。所以接下来，就只需从检测结果中取出棋子的位置，以及最上面一个非棋子物体，即目标块的位置。有了物体的边界轮廓，取中点即可得到棋子和目标块的水平坐标，这里进行了归一化，即屏幕宽度为1，距离在0至1之间。然后将距离乘以一个系数，作为长按时间并模拟执行即可。运行结果看起来很不错，实际跑分结果如何呢？大概只能达到几百分，问题出在哪？主要是标注数据太少，模型训练得不够充分，所以检测结果不够准确，有时候检测不出棋子和目标块，而一旦出现这类问题，分数必然就断了。尝试了以下方法，将一张截图朝不同的方向平移，从而得到九张截图，希望提高检测结果的召回率，但仍然有检测不出来的情况，也许只有靠更多的标注数据才能解决这一问题。规则检测模型训练了20W轮，依旧存在检测不出来的情况，郁闷得很，干脆也写一个基于规则的 简单版代码 好了。花了不到20分钟写完代码，用OpenCV提取边缘，然后检测棋子和目标块的水平中心位置，结果看起来像这样。事实证明，最后跑出来的分数，比之前的模型要高多了……说好的深度学习呢？总结面对以下情况时，基于人工经验定义规则，比用深度学习训练模型要省力、有效很多：问题本身比较简单，不需要复杂的抽象；标注数据比较有限，难以充分训练模型；错误惩罚很高，对错误不能容忍。即便模型在99%的情况下能完美运行，1%的错误立马让游戏直接结束了，此时反而不如hard code的规则靠谱。当然，如果大家能一起努力，多弄些标注数据出来，说不定还有些希望。代码在Github上：github.com/Honlan/wech…不说了，我继续刷分去了，用后面写的不到一百行的代码……"}
{"title": "合并微信小程序中的会话管理和业务服务器 ", "author": "Rolan", "pub_time": "2018-1-8 00:11", "article_content": "云服务器列表到期啦！！！！文件迁移\r\n因为两台服务器的镜像是不同的，里面的环境也不同。业务服务器是nginx+php-fpm的环境，而会话服务器是LAMP (Apache)。\r\n首先把登录会话服务器，把文件传到业务服务器来。\r\n会话服务器(172.16.0.15) /opt/lampp/htdocs/mina_auth 迁移到 ->业务服务器(172.16.0.8) /data/release/session-wafer/mina_auth\r\n[root@VM_0_15_centos htdocs]# pwd/opt/lampp/htdocs[root@VM_0_15_centos htdocs]# lsmina_auth  update_mina.sh[root@VM_0_15_centos htdocs]# tar czvf session.tar.gz mina_auth\r\n打包完成之后，把文件通过scp复制过去。\r\nscp /opt/lampp/htdocs/session.tar.gz root@172.16.0.8:/data/release/\r\n文件复制然后，登录业务服务器\r\n停掉php-fpm服务，命令：kill -QUIT cat /run/php-fpm/php-fpm.pid\r\n停掉nginx服务，命令：nginx -s stop\r\n解压session.tar.gz命令：tar xzvf session.tar.gz\r\n把mina_auth创建到正确的目录下面。\r\n设置nginx\r\n因为业务服务器已经跑在了80端口，因而我们现在把会话服务器配置到8080端口会更加合理。所以我们是让一个nginx同时支持多个端口。\r\n默认nginx有两个配置文件\r\n\r\n/etc/nginx/nginx.conf 这个是主配置文件，打开查看可以发现在末端它引用了目录 /etc/nginx/conf.d 里面的所有配置文件；\r\n/etc/nginx/conf.d/php-weapp-demo.conf 这个是80端口的业务服务器的配置；(我个人把它改了名字 application-wafer.conf)\r\n\r\n把application-wafer.conf复制一份，起名为session-wafer.conf，并修改下面的内容。\r\n这个时候，似乎掺的配置都修改完成了，但是还不能运行起来的，必须在程序上做一些修改。特别是加解密部分，可是花了赞哥成天的时间找出来。\r\n修改小程序sdk配置\r\n位置： /etc/qcloud/sdk.config\r\n把这个地址改成你业务服务器本机的地址。如，我从 172.16.0.15 变成了 172.16.0.8:8080\r\n修改解密算法\r\n为这个问题我找了一天时间，非常郁闷。\r\n位置：/data/release/session-wafer/minaauth/system/wxdecrypt_data/new/pkcs7Encoder.php\r\n问题描述：\r\n在会话服务器里，mcrypt插件是已经随LAMP安装了的，而在业务服务器，并没有这个插件。请看下面的phpinfo。（你需要在php.ini里面把phpinfo生产才能查看）\r\n会话服务器里mcrypt是enabled的原来打算在业务服务器上安装mcrypt插件，但是查看php的官网，特别是php 7.1后，mcrypt是特别不建议使用的，其可以用openssl替代。\r\n$decrypted = openssldecrypt(aesCipher,′aes−128−cbc′,this->key, OPENSSLRAW_DATA, $aesIV);\r\n修改后的效果为：\r\n重新启动服务器\r\n启动nginx和php-fpm，直接高点命令nginx和php-fpm\r\n启动两个服务测试工作\r\ncurl http://localhost/curl http://localhost:8080/mina_auth/\r\n注意：8080端口是默认不能通过外网访问进来的，只能通过VPC内网。"}
{"title": "微信小程序实现滚动加载更多 ", "author": "Rolan", "pub_time": "2018-1-12 00:10", "article_content": "1.需要用到的组件和api\r\nscroll-view（可滚动视图区域）\r\nwx.showToast(OBJECT)显示消息提示窗----显示loading小菊花用的\r\n2.需要用到的属性\r\n3.scrol-view需要指定一个高度，这个高度可以按自己的需求计算，我使用的是屏幕可用高度并且默认一页显示6个\r\n4.滚动到底部绑定需要触发的事件\r\n<scroll-view scroll-y='true' style=\"height:{{height}}px\" bindscrolltolower='lower'>\r\n5.操作事件函数，主要是将请求下来的数据用concat方法进行合并，然后赋值，我是用的for循环假装添加的数据，实际项目中可以换成自己的ajax，并且为了模拟加载我添加了一个1.5秒的定时器，先调用提示框api成功之后关闭\r\n  lower() {    var result = this.data.res;    var resArr = [];　　//这里可以使用自己的ajax    for (let i = 0; i < 10; i++) {      resArr.push(i);    };    var cont = result.concat(resArr);//合并请求的数据    console.log(resArr.length);    if (cont.length >= 100) {      wx.showToast({ //期间为了显示效果可以添加一个过度的弹出框提示“加载中”          title: '我也是有底线的',        icon: 'success',        duration: 300      });      return false;    } else {      wx.showLoading({ //期间为了显示效果可以添加一个过度的弹出框提示“加载中”          title: '加载中',        icon: 'loading',      });      setTimeout(() => {        this.setData({          res: cont        });        wx.hideLoading();      }, 1500)    }  }\r\n6.成功，放完整代码可以直接复制运行\r\nwxml代码\r\nclass='box'><scroll-view scroll-y='true' style=\"height:{{height}}px\" bindscrolltolower='lower'>  <view wx:for=\"{{res}}\" data-id=\"{{index}}\" wx:key=\"{{index}}\" style=\"height:{{(height/6)-1}}px;width:100%;text-align:center;line-height:{{(height/6)-1}}px; border-bottom:1px solid #ccc\">{{item}}view>scroll-view>view>\r\njs代码\r\nPage({  /**   * 页面的初始数据   */  data: {    height: '',    res: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  },  lower() {    var result = this.data.res;    var resArr = [];    for (let i = 0; i < 10; i++) {      resArr.push(i);    };    var cont = result.concat(resArr);    console.log(resArr.length);    if (cont.length >= 100) {      wx.showToast({ //如果全部加载完成了也弹一个框        title: '我也是有底线的',        icon: 'success',        duration: 300      });      return false;    } else {      wx.showLoading({ //期间为了显示效果可以添加一个过度的弹出框提示“加载中”          title: '加载中',        icon: 'loading',      });      setTimeout(() => {        this.setData({          res: cont        });        wx.hideLoading();      }, 1500)    }  },  /**   * 生命周期函数--监听页面加载   */  onLoad: function (options) {    wx.getSystemInfo({      success: (res) => {        this.setData({          height: res.windowHeight        })      }    })  }})"}
{"title": "微信小程序简单的推送消息流程 ", "author": "Rolan", "pub_time": "2018-1-12 00:12", "article_content": "1.进入开发设置-消息推送，启用消息推送url: 启用并设置消息推送配置后，用户发给小程序的消息以及开发者需要的事件推送，都将被微信转发至该服务器地址中. 2.创建消息模板。  3.WXML代码：4.获取 access_token发送模板消息注意：formId只有在手机上才能看到，开发工具上是看不到的。 5.这只是在前台开发的，要想推送消息，应该将推送消息等参数发送到后台接口，由后台来实现推送消息。"}
{"title": "基于bmob快速搭建小程序用户模块（包括登录、当前用户、用户安全） ... ", "author": "bmob小小琪", "pub_time": "2018-1-12 15:04", "article_content": "一键登录开发小程序登录后端工作：客户端调用wx.login()后获取的code，后端人员拿到code和微信换取openid和session_key；除此之外后端人员还需要根据openid生成sessiontoken作为服务器和小程序之间做登录态校验保证安全性，客户端每次请求需要带上sessiontoken，后端需要作校验；还需要提供接口给客户端保存用户信息（头像、名称等），或者根据openid去和微信换取用户信息；中间的过程的调试还需要花费大量的时间利用bmob的小程序sdk的实现一键登录：以上后端开发工作全省了！！    wx.login({        success: function (res) {          var user = new Bmob.User();//实例化                    user.loginWithWeapp(res.code).then(function (user) {            if (user.get(\"nickName\")) {              //更新缓存中的openid              wx.setStorageSync('openid', user.get(\"openid\"))            } else {              //*************保存用户其他信息，比如昵称头像之类的*****************              wx.getUserInfo({                success: function (result) {                  var nickName = result.userInfo.nickName;                  var avatarUrl = result.userInfo.avatarUrl;                  var u = Bmob.Object.extend(\"_User\");                  var query = new Bmob.Query(u);                  // 这个 id 是要修改条目的 id，你在生成这个存储并成功时可以获取到，请看前面的文档                  query.get(user.id, {                    success: function (result) {                      // 自动绑定之前的账号                      result.set('nickName', nickName);                      result.set(\"userPic\", avatarUrl);                      result.set(\"openid\", openid);                      result.save();                    }                  });                }              });              //*************保存用户其他信息，比如昵称头像之类的end*****************            }          }, function (err) {            console.log(err, 'errr');          });        }      });    }user用户对象中的loginWithWeapp方法使用当前使用小程序的微信用户身份注册或登录，成功后用户的 session 会在设备上持久化保存，之后可以使用 Bmob.User.current() 获取当前登录用户如果该用户是第一次使用此应用，调用登录 API 会创建一个新的用户，你可以在 控制台 >应用> 数据 中的 _User表中看到该用户的信息，如果该用户曾经使用该方式登录过此应用，再次调用登录 API 会返回同一个用户。登录后获取到一个用户数据对象，包括用户唯一标识objectId、openid、nickName、avatarUrl、authData，authData包括sessiontoken登录校验，小程序sdk封装了请求带上了缓存authData的sessiontoken，所以session_token这部分 不需要bmob的开发者考虑；当前用户如果用户每次打开App的时候都要求登录无疑是令人感到厌烦的，你可以通过缓存当前的Bmob.User对象来避免这个问题。无论你使用任何注册或者登录方法，用户都会在localStorage中储存，你可以把缓存作为一个session对待，并且自动假设用户已经登录了。你可以操作Bmob.User.current()来获取当前用户的信息var currentUser = Bmob.User.current();用户安全Bmob.User类默认就是受保护的，在Bmob.User中保存的数据只能被那个用户所修改。默认地，数据仍然可以被任意客户端所读取。这样就是说，有些Bmob.User对象被认证后是可以修改的，其他的仍然是只读的。特别的，你不能调用save或者delete方法除非Bmob.User经过了认证，就比如调用过了logIn或者signUp方法，这样保证只有用户能改动他们自身的数据。"}
{"title": "入坑微信小程序（项目搭建）上 ", "author": "Rolan", "pub_time": "2018-1-15 00:16", "article_content": "超荣幸能够参与我司【更美小程序】的搭建，在此分享些心得希望能够帮助到像我一样的前端界萌新。因【更美小程序】源码需保密，我仅向大家分享基础建设级别的非业务代码。点我~一个最基本的小程序项目需具备：app.js（入口文件）、app.json（全局配置）、app.wxss（通用样式）、pages/（页面）。pages/ 下的每一页面拥有独自的 .js、.json、.wxss。形如：想了解更多请参考 微信小程序代码构成。对于中大型项目需明确划分功能模块，我司小程序文件目录如下：assets ：静态资源 及 tabBar 支持引用本地静态资源，而 wxss 中 background-image 不支持，但支持引用 base64 及网络资源。components ：公用组件templates ：公用模板组件 与 模板 的应用场景易混淆。父节点可向组件也可向模板传入 data 控制其视图。然组件的优势在于其 数据监听 、 事件监听 、 生命周期 等机制，自行科普 component 构造器 你便明了。但构造组件成本较高，json、wxml、wxss、js 需齐备：反之模板较轻便，构造 wxml 接收 page data 即可：<template name=\"mError\">\r\n    <view class=\"mError\">\r\n        <image src=\"/assets/images/holder_error.png\">image>\r\n        <text>网络错误text>\r\n    view>\r\ntemplate>\r\n<template is=\"mError\" />将模块封装为组件或是模板需开发者分析其特性并结合业务场景定夺（纯粹的视图控制请选择模板）。settings ：配置文件module.exports = {\r\n    version: '1.0.0',\r\n    server: 'https://backend.igengmei.com',\r\n    release: 1\r\n}开发阶段的网络环境往往与生产阶段不同， settings.js 配置了生产环境，需自行创建 settings_local.js （不入库）配置开发环境。var settings = require('settings');\r\nvar settings_local = null;\r\ntry {settings_local = require('settings_local');} catch (err) {}\r\nmodule.exports = settings_local || settings上述脚本会优先 export settings_local.js 内配置。也可将 server 配置为本地服务，然小程序合法域名不支持 localhost...我们可在开发阶段“不校验安全域名、TLS 版本以及 HTTPS 证书”。utils ：公用脚本utils 类脚本非全局注册需在 page 内 import 方可调用。 app.js 内注册的全局函数无需 import，可通过 app.method(params) 直接调用：// utils 类脚本\r\nimport Common from '../../utils/common'\r\n\r\nconst app = getApp();\r\nPage({\r\n    data: {},\r\n    ...Common,  \r\n    onLoad: function () {\r\n        this.exampleRequest();\r\n        // 全局注册类脚本\r\n        app.showToast(this, {\r\n            message: '呆恋小喵一枚',\r\n            duration: 3000,\r\n            type: 'common'\r\n        });\r\n    },\r\n    exampleRequest: function () {\r\n        // 全局注册类脚本  \r\n        app.request({\r\n            url: 'url',\r\n            method: 'GET'\r\n        });\r\n    }\r\n});  全局注册使用率高的模块，可减少 page 内的 import，例如 app.request(params)、app.showToast(params) 等：import { getBaseInfo } from 'utils/baseInfo'\r\nimport Request from 'utils/request'\r\nimport Toast from 'utils/toast'\r\n  \r\nApp({\r\n    GLOBAL: {\r\n        baseInfo: getBaseInfo()\r\n    },\r\n    request: function (params) {\r\n        Request(params);\r\n    },\r\n    showToast: function (page, opts) {\r\n        Toast.show(page, opts);\r\n    }\r\n});也可在 GLOBAL 内注册一些全局 data，在 page 内通过 app.GLOBAL 获取。踩坑札记关于 tabBarapp.json 内可配置 tabBar 的 pagePath、text、iconPath、selectedIconPath，但图标尺寸、文字大小、元素间距不可自定义。icon 尺寸建议为 81px * 81px，若 icon 切图恰好撑满画布，图标与文字便相互紧贴不美观。故 icon 切图底边距需有所保留：关于 toast小程序自带 wx.showToast 必须传入 icon：wx.showToast({\r\n    title: '成功',\r\n    icon: 'success',\r\n    duration: 2000\r\n});但我想使用朴素的 toast：自行封装 toast 捎带默认类型及自定义类型是个不错的选择：switch (opts.type) {\r\n    case 'common':\r\n        page.setData({\r\n            'render.toast.show': true,\r\n            'render.toast.message': opts.message\r\n        });\r\n        let t = setTimeout(() => {\r\n            page.setData({\r\n                'render.toast.show': false,\r\n                'render.toast.message': ''\r\n            });\r\n            opts.callback();\r\n        }, opts.duration);\r\n        break;\r\n    case 'loading':\r\n        wx.showToast({\r\n            title: opts.message,\r\n            duration: opts.duration,\r\n            icon: 'loading'\r\n        });\r\n        break;\r\n    case 'success':\r\n        wx.showToast({\r\n            title: opts.message,\r\n            duration: opts.duration,\r\n            icon: 'success'\r\n        });\r\n        break;\r\n}关于  渲染时不会将 nodes 解析为常规标签，你只能拿到这样一大坨：无法直接获取其中的 dom，且不可在 .wxss 中定义其样式故必须添加内联 style。且  无法对 nodes 自动纠错：例如部分浏览器可解析 一段错误代码 ，  则直接过滤错误代码不进行渲染。关于 onPullDownRefreshenablePullDownRefresh 仅可开启 pulldown 的交互及监听，并非想象中的 window.location.reload 。我们需要定义自己的 reload：reload: function (page, callback) {\r\n    page.setData({\r\n        reqError: false\r\n    });\r\n    callback && callback();\r\n    page.onLoad();\r\n    page.onReady();\r\n}onPullDownRefresh: function () {\r\n    const _page = this;\r\n    Loadmore.clear(_page);\r\n    app.reload(_page, function () {\r\n        _page.setData({\r\n            'render.orders': [],\r\n            'render.loading': true,\r\n            'render.empty.show': false\r\n        });\r\n    });\r\n    wx.stopPullDownRefresh();\r\n}小程序无 window 概念，不可调用 window.location.reload 。其实 reload 无非 重置 data 、重新调用 onLoad 及 onReady （原谅我这肤浅的理解，但你可在 callback 中做任何意义上的重置）。在 onPullDownRefresh 回调执行时 wx.stopPullDownRefresh() 防止用户疯狂 pulldown 导致卡涩。关于 wx.getSystemInfo调用 wx.getSystemInfo 可获取设备信息，fail 回调限制了获取失败时的尝试次数：function getMobileInfo(i) {\r\n    wx.getSystemInfo({\r\n        success: (res) => {\r\n            BaseInfo.mobile = res.brand + res.model;\r\n            BaseInfo.system = res.platform + res.system;\r\n            BaseInfo.wechat = res.version;\r\n            BaseInfo.winWidth = res.windowWidth / (res.windowWidth / 750);\r\n            BaseInfo.winHeight = res.windowHeight / (res.windowWidth / 750);\r\n        },\r\n        fail: () => {\r\n            (i < 3) && getMobileInfo(i + 1);\r\n        }\r\n    });\r\n}\r\ngetMobileInfo(0);请注意 windowWidth、windowHeight 度量单位为 px，而我司项目规定使用 rpx。为实现单位统一，需对 windowWidth 及 windowHeight 做单位转换：BaseInfo.winWidth = res.windowWidth / (res.windowWidth / 750);\r\nBaseInfo.winHeight = res.windowHeight / (res.windowWidth / 750);1rpx = (设备宽度 / 750) px"}
{"title": "入坑微信小程序（项目搭建）下 ", "author": "Rolan", "pub_time": "2018-1-15 00:37", "article_content": "关于 wx.getLocation首次 执行 wx.getLocation 小程序将自动调启如下 dialog：请注意是 首次 ！无论用户选择“确定”或是“取消”，再次进入“更美测试”均不会被询问是否开启定位（调用 100 次 wx.getLocation 也无济于事）。除非用户手动清理微信缓存、更新微信、切换账号...各种缓存：存在上述问题的 API 绝不止 wx.getLocation 例如 wx.login，遗憾的是，小程序并未开放清理缓存的接口。但可通过 wx.openSetting 再次请求用户开启授权：关于 wx.reportAnalytics小程序数据分析可通过填写配置上报、API 上报：对于填写配置上报，需提交触发动作、触发页面、触发元素、埋点数据等。但埋点数据需从 page data 中获取，看看官方文档是怎么曰的：OMG...需要在 page data 内维护埋点状态，当埋点量较大时上报数据的复杂度可想而知。我曾傻傻的认为 data 字段值等同 dataset 值：<text\r\n    wx:for=\"{{ areas }}\"\r\n    data-id=\"{{ item.id }}\"\r\n    data-name=\"{{ item.name }}\"\r\n    data-idx=\"{{ index }}\"\r\n    bindtap=\"tapItem\">{{ item.name }}</text>未曾想竟为 page 实例中的 data 值：Page({\r\n    data: {},\r\n    onLoad: function () {},\r\n    onReady: function () {}\r\n});如此看来 API 上报更简单，为触发元素 dataset 埋点数据并调用 wx.reportAnalytics 传入参数：<text\r\n    wx:for=\"{{ orders }}\"\r\n    data-id=\"{{ item.id }}\"\r\n    data-name=\"{{ item.name }}\"\r\n    data-type=\"order\"\r\n    bindtap=\"triggerSelected\">{{ item.name }}</text>triggerSelected (e) {\r\n    var dataset = e.target.dataset;\r\n    var id = dataset.id;\r\n    var name = dataset.name;\r\n    var type = dataset.type;\r\n    wx.reportAnalytics('click_fliter_item', {\r\n        item_type: type,\r\n        item_id: id,\r\n        item_name: name\r\n    });\r\n}关于 rpxrpx 在不同设备被小程序换算为 px 时能产生各种 bug，当设备宽度除不尽 750 时结果值精确至哪一位呢（额...bug 产生原因本人猜的），看看换算表：举个例子：<view class=\"fliter-bar\" style=\"top: {{ top }}rpx;\"></view>\r\n<view class=\"fliter-wrap\" style=\"top: {{ top + 84 }}rpx;\"></view>问题一：当 top = 0 时，0rpx 被换算为 0.5px 也是厉害~解决方案：<view class=\"fliter-bar\" style=\"top: {{ top ? (top + 'rpx') : 0 }};\"></view>问题二：当 fliter-bar 高度为 84rpx，理论上紧贴的 fliter-bar 与 fliter-wrap 在部分设备上也不紧贴...关于 setData假如你想在 this.setData 的 key 中传入变量，下述写法报错：triggerSelected (e) {\r\n    var dataset = e.target.dataset;\r\n    var id = dataset.id;\r\n    var name = dataset.name;\r\n    var type = dataset.type;\r\n    this.setData({\r\n        selected[type]: {\r\n            id: id,\r\n            name: name\r\n        }\r\n    });\r\n}且 this.setData 不支持模板字符串形式的 key，下述写法也报错：triggerSelected (e) {\r\n    var dataset = e.target.dataset;\r\n    var id = dataset.id;\r\n    var name = dataset.name;\r\n    var type = dataset.type;\r\n    this.setData({\r\n        `selected.${type}`: {\r\n            id: id,\r\n            name: name\r\n        }\r\n    });\r\n}可将 selected 存入变量，直接操作 selected 变量后再 this.setData：triggerSelected (e) {\r\n    var dataset = e.target.dataset;\r\n    var id = dataset.id;\r\n    var name = dataset.name;\r\n    var type = dataset.type;\r\n    var selected = this.data.selected;\r\n    selected[type] = {\r\n        id: id,\r\n        name: name\r\n    };\r\n    this.setData({\r\n        selected: selected\r\n    });\r\n}检测 page data 内 selected 值与预期的一致，但当 selected 与视图渲染相关时，意想不到的情况发生了...假定我通过 selected 的某一属性值控制元素 class：<text\r\n    class=\"{{ selected.order.id == item.id ? 'active' : '' }}\"\r\n    wx:for=\"{{ orders }}\"\r\n    data-id=\"{{ item.id }}\"\r\n    data-name=\"{{ item.name }}\"\r\n    data-type=\"order\"\r\n    bindtap=\"triggerSelected\">{{ item.name }}</text>当元素被点击时其 class 被赋值 active 使之呈现绿色：而后我点击了另一与之前被点击元素 type 不同的元素，理论上不应影响第一次被点击元素的状态（selected.type2 变化不影响 selected.type1），然而：active 仍在绿色却不见了，这 bug 也是醉了，我不得不写点烂代码了（通过 switch case 一一处理）：triggerSelected (e) {\r\n    var dataset = e.target.dataset;\r\n    var id = dataset.id;\r\n    var name = dataset.name;\r\n    var type = dataset.type;\r\n    var selected = this.data.selected;\r\n    switch (type) {\r\n        case 'area':\r\n            this.setData({\r\n                'selected.area': {\r\n                    id: id,\r\n                    name: name\r\n                }\r\n            });\r\n            break;\r\n        case 'tag':\r\n            this.setData({\r\n                'selected.tag': {\r\n                    id: id,\r\n                    name: name\r\n                }\r\n            });\r\n            break;\r\n        case 'order':\r\n            this.setData({\r\n                'selected.order': {\r\n                    id: id,\r\n                    name: name\r\n                }\r\n            });\r\n            break;\r\n    }\r\n}未完待续，谢谢关注~作者：呆恋小喵我的后花园：https://sunmengyuan.github.io...我的 github：https://github.com/sunmengyuan原文链接：https://sunmengyuan.github.io..."}
